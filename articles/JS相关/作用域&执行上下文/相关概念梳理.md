### 什么叫变量提升
JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升。

### 作用域
指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期

### `let`和`const`的“暂时性死区”
通过`let`和`const`声明的变量会在进入块级作用域时被创建，但是在该变量没有赋值之前，引用该变量JavaScript引擎会抛出错误---这就是“暂时性死区”

### 词法作用域
指的是作用域是由代码中**函数声明的位置**来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符</br>

**也就是说词法作用域是代码阶段就决定好了，和函数怎么调用的没有关系**

### 作用域链
当代码在一个环境中创建时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境。
作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。

每个执行上下文的**变量环境**中，都包含一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为**outer**

当我们查找某个变量时，如果在当前的变量环境中没有查找到，那么JS引擎会继续在outer所指向的执行上下文中查找。


eg：在A函数中查找某个变量，先看A函数的执行上下文中有没有，如果没有，再看**A函数是在哪个作用域下定义的**，也就是A函数的上级作用域，在这个上级作用域中继续寻找变量

```
function bar(){
    console.log(myName)
}

function foo(){
    var myName = '极客邦'
    bar()
}
var myName = "极客时间"
foo()
```

输出：“极客时间”
**根据词法作用域，foo和bar的上级作用域都是全局作用域**

### 调用栈
管理执行上下文的栈


### 执行上下文
当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution contexts)。**是JavaScript执行一段代码时的运行环境**
### 几种执行上下文

- Global code-------> 全局执行上下文
- Function code-----> 函数执行上下文
- Eval code ------> eval函数执行上下文

### 闭包
闭包指有权访问另一个函数作用域中的变量的函数。

**在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包**


eg:
```
var bar = { myName:"time.geekbang.com", printName: function () { console.log(myName) } }
function foo() { let myName = "极客时间" return bar.printName}
let myName = "极客邦"
let _printName = foo()
_printName()
bar.printName()
```
an:打印两次“极客帮”






