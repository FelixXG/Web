### 满足递归的几个条件

- 一个问题的解可以分解为几个子问题的解
- 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
- 存在递归终止条件



### 如何编写递归代码
写递归代码最关键的是**写出递推公式，找到终止条件**。


### demo（走台阶）
- 递归
```
f(n){
    if(n == 1) reutrn 1;
    if(n == 2) reutrn 2;
    return f(n-1) + f(n-2);
}
```
- 非递归
```
f(n){
    if(n == 1) return 1;
    if(n == 2) return 2;
    
    let ret = 0;
    let pre = 2;
    let prepre = 1;
    for(let i = 3;i<=n;i++){
        ret = pre + prepre;
        prepre = pre;
        pre =ret;
    }
    return ret;
}
```

### 问题
- 是不是所有递归代码都可以改为这种迭代循环的非递归写法呢？</br>
笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。

写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码

